// Generated by LiveScript 1.4.0
(function(){
  var Game, FillRowGame, TicTacToeGame;
  Game = (function(){
    Game.displayName = 'Game';
    var prototype = Game.prototype, constructor = Game;
    function Game(size, cellDefaultValue, cellTouchedValue){
      var ref$;
      this.size = size;
      this.cellDefaultValue = cellDefaultValue != null ? cellDefaultValue : 0;
      this.cellTouchedValue = cellTouchedValue != null ? cellTouchedValue : 1;
      this.size = (ref$ = this.size) === 2 || ref$ === 3 || ref$ === 4 || ref$ === 5 || ref$ === 6 || ref$ === 7 || ref$ === 8 || ref$ === 9 || ref$ === 10 || ref$ === 11 || ref$ === 12 ? size : 4;
      /*
       * data is a vector that contains 0 and 1
       * (if cell is empty => 0 else => 1)
       *
       */
      this.data = repeatArray$(repeatArray$([0], this.size), this.size);
      /*
       * current player is number of player, whose turn
       * is at moment
       *
       */
      this.currentPlayer = null;
      /*
       * start position is the number of cell, from which
       * it will fill cells
       */
      this.startPos = null;
      /*
       * field is the table wich contains all cells
       *
       */
      this.field = new Field(this.size, this.selectCell, this.cellDefaultValue);
      /*
       * calling next turn will set player to 1
       * and print all necessary messages
       *
       */
      this.nextTurn();
    }
    prototype.selectCell = function(obj){};
    prototype.checkGameOver = function(){
      if (this.isGameOver()) {
        Info.postAlertMessage("Победа за игроком номер " + this.currentPlayer);
        return createGameFromParams();
      } else {
        return this.nextTurn();
      }
    };
    prototype.isGameOver = function(){};
    prototype.nextTurn = function(){
      this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
      Info.postPlayerInfoMessage("Ход " + this.currentPlayer + " игрока");
      Info.postStateMessage("Выберите начальную клетку");
      return this.startPos = null;
    };
    return Game;
  }());
  FillRowGame = (function(superclass){
    var prototype = extend$((import$(FillRowGame, superclass).displayName = 'FillRowGame', FillRowGame), superclass).prototype, constructor = FillRowGame;
    prototype.selectCell = function(obj){
      /*
       * Firstly check if cell is already filled
       *
       */
      if (this.data[this.field.getCellNumber(obj.target)]) {
        return;
      }
      /*
       * Then check start position and set them if
       * it isn't setted
       *
       */
      if (this.startPos != null) {
        if (this.canFillCells(this.startPos, this.field.getCellNumber(obj.target))) {
          this.fillCells(this.startPos, this.field.getCellNumber(obj.target));
          return this.checkGameOver();
        }
      } else {
        this.startPos = this.field.getCellNumber(obj.target);
        this.field.setCellStart(this.startPos);
        return Info.postStateMessage("Выберите конечную клетку");
      }
    };
    prototype.fillCells = function(startPos, endPos){
      /*
       * swap min and max
       *
       */
      var isColumn, i$, j, results$ = [];
      if (startPos > endPos) {
        startPos = [endPos, endPos = startPos][0];
      }
      isColumn = this.isColumn(startPos, endPos);
      for (i$ = startPos; i$ <= endPos; ++i$) {
        j = i$;
        if (j % this.size === endPos % this.size && isColumn || !isColumn) {
          /*
           * if it's column then fill vertical
           * else horizontal
           *
           */
          this.data[j] = 1;
          this.field.setCellData(j, this.cellTouchedValue);
          results$.push(this.field.setCellTouched(j));
        }
      }
      return results$;
    };
    prototype.isColumn = function(startPos, endPos){
      return endPos - startPos >= this.size || (endPos / this.size | 0) !== (startPos / this.size | 0);
    };
    prototype.canFillCells = function(startPos, endPos){
      /*
       * look at fillCells
       *
       */
      var isColumn, i$, j;
      if (startPos > endPos) {
        startPos = [endPos, endPos = startPos][0];
      }
      isColumn = this.isColumn(startPos, endPos);
      if (isColumn && (endPos - startPos) % this.size) {
        return false;
      }
      for (i$ = startPos; i$ <= endPos; ++i$) {
        j = i$;
        if (j % this.size === endPos % this.size && isColumn || !isColumn) {
          if (this.data[j]) {
            return false;
          }
        }
      }
      return true;
    };
    prototype.isGameOver = function(){
      return !this.data.filter(function(a){
        return a === 0;
      }).length;
    };
    function FillRowGame(){
      this.isGameOver = bind$(this, 'isGameOver', prototype);
      this.canFillCells = bind$(this, 'canFillCells', prototype);
      this.fillCells = bind$(this, 'fillCells', prototype);
      this.selectCell = bind$(this, 'selectCell', prototype);
      FillRowGame.superclass.apply(this, arguments);
    }
    return FillRowGame;
  }(Game));
  TicTacToeGame = (function(superclass){
    var prototype = extend$((import$(TicTacToeGame, superclass).displayName = 'TicTacToeGame', TicTacToeGame), superclass).prototype, constructor = TicTacToeGame;
    function TicTacToeGame(size, cellDefaultValue, cellTouchedValue, length){
      this.size = size;
      this.cellDefaultValue = cellDefaultValue != null ? cellDefaultValue : 0;
      this.cellTouchedValue = cellTouchedValue != null ? cellTouchedValue : 1;
      this.length = length;
      this.selectCell = bind$(this, 'selectCell', prototype);
      this.length = in$(this.length, (function(){
        var i$, to$, results$ = [];
        for (i$ = 1, to$ = this.size; i$ <= to$; ++i$) {
          results$.push(i$);
        }
        return results$;
      }.call(this)))
        ? this.length
        : this.size;
      TicTacToeGame.superclass.apply(this, arguments);
    }
    prototype.selectCell = function(obj){
      if (this.data[this.field.getCellNumber(obj.target)]) {
        return;
      }
      this.startPos = this.field.getCellNumber(obj.target);
      this.data[this.startPos] = 1;
      this.field.setCellTouched(this.startPos);
      this.field.setCellData(this.startPos, this.cellTouchedValue);
      return this.checkGameOver();
    };
    prototype.isGameOver = function(){
      var i$, to$, j, this$ = this;
      for (i$ = 0, to$ = this.size; i$ <= to$; ++i$) {
        j = i$;
        if (!![(fn$.call(this)).join(""), (fn1$.call(this)).join(""), (fn2$.call(this)).join(""), j ? (fn3$.call(this)).join("") : "", (fn4$.call(this)).join(""), j ? (fn5$.call(this)).join("") : ""].filter(fn6$).length) {
          return true;
        }
      }
      return false;
      function fn$(){
        var x$, ref$, i$, to$, results$ = [];
        ref$ = this.data;
        for (i$ = j * this.size, to$ = (j + 1) * this.size - 1; i$ <= to$; ++i$) {
          x$ = i$;
          if (x$ < ref$.length) {
            results$.push(ref$[x$]);
          }
        }
        return results$;
      }
      function fn1$(){
        var x$, ref$, i$, step$, to$, results$ = [];
        ref$ = this.data;
        for (i$ = j, to$ = Math.pow(this.size, 2) - this.size + j, step$ = this.size; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
          x$ = i$;
          if (x$ < ref$.length) {
            results$.push(ref$[x$]);
          }
        }
        return results$;
      }
      function fn2$(){
        var x$, ref$, i$, step$, to$, results$ = [];
        ref$ = this.data;
        for (i$ = j, to$ = Math.pow(this.size, 2) - j * this.size, step$ = this.size + 1; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
          x$ = i$;
          if (x$ < ref$.length) {
            results$.push(ref$[x$]);
          }
        }
        return results$;
      }
      function fn3$(){
        var x$, ref$, i$, step$, to$, results$ = [];
        ref$ = this.data;
        for (i$ = j * this.size, to$ = Math.pow(this.size, 2), step$ = this.size + 1; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
          x$ = i$;
          if (x$ < ref$.length) {
            results$.push(ref$[x$]);
          }
        }
        return results$;
      }
      function fn4$(){
        var x$, ref$, i$, step$, to$, results$ = [];
        ref$ = this.data;
        for (i$ = this.size - 1 - j, to$ = Math.pow(this.size, 2) - j * this.size - 2, step$ = this.size - 1; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
          x$ = i$;
          if (x$ < ref$.length) {
            results$.push(ref$[x$]);
          }
        }
        return results$;
      }
      function fn5$(){
        var x$, ref$, i$, step$, to$, results$ = [];
        ref$ = this.data;
        for (i$ = (j + 1) * this.size - 1, to$ = Math.pow(this.size, 2), step$ = this.size - 1; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
          x$ = i$;
          if (x$ < ref$.length) {
            results$.push(ref$[x$]);
          }
        }
        return results$;
      }
      function fn6$(a){
        return a.indexOf(repeatString$('1', this$.length)) > -1;
      }
    };
    return TicTacToeGame;
  }(Game));
  this.FillRowGame = FillRowGame;
  this.TicTacToeGame = TicTacToeGame;
  function repeatArray$(arr, n){
    for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
      if (n & 1) r.push.apply(r, arr);
    return r;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);
